import scala.util.Random

/* pi is an M length array of unnormalized initial state probabilities
 * T is an MxM matrix of state transition probabilities (Transition Matrix)
 * A is an MxO matrix of emission probabilities where O is the number
 *   of possible emission possibilities in any state (Action Matrix)
 *
 * PRCONDITIONS:
 *   T must be square
 *   A must have the same number of rows as T
 *
 * Probability matrices may be unnormalized
 */
class Hmm(val pi: Array[Double], val T: Array[Array[Double]],
	  val A:  Array[Array[Double]]) {

  val rand = new Random()
  val numStates  = T.length
  val numActions = A.length

  def genObsSeq(steps: Int): Seq[Int] = {
    val observations: Array[Int] = new Array[Int](steps)

    var step = 0
    var currState = inverseSample(pi)
    while(step < steps) {
      observations(step) = inverseSample(A(currState))
      currState = inverseSample(T(currState))
      step = step + 1
    }

    return observations
  }

  /* FUTURE WORK: 1) scale probabilities to prevent underflow
   *
   * This function implements the forward algorithm (given a set of
   * observations, it returns the probability of that set of observations
   * having come from THIS Hmm).
   *
   * PRECONDITIONS:
   *   This Hmm must have an A and a T matrix
   *   all of the observations should be valid (could have possibly been
   *     generated by this Hmm
   */
  def forward(obsSeq: Seq[Int]): Double = {
    var prevTrellis = new Array[Double](numStates)
    var currTrellis = new Array[Double](numStates)

    var obsItr    = 0
    var stateItr  = 0   // generic itr
    var currState = 0
    while(stateItr < numStates) {        // Initialize
      prevTrellis(stateItr) = pi(stateItr) * A(stateItr)(obsSeq(obsItr));
      stateItr = stateItr + 1
    }

    var alpha = 0.0     // alpha stores partial sums of the probability of
                        // of being in a given state after having seen the
                        // first N tokens of the observation sequence
    obsItr    = 1
    while (obsItr < obsSeq.length) {

      currState = 0
      while (currState < numStates) {

	alpha    = 0.0
	stateItr = 0
	while (stateItr < numStates) {
	  // I should replace the line below with a dot product
	  alpha    = alpha + prevTrellis(stateItr) * T(stateItr)(currState)
	  stateItr = stateItr + 1
	}

	alpha = alpha * A(currState)(obsSeq(obsItr))
	currTrellis(currState) = alpha
	currState = currState + 1
      }

      // NOTE: at this point, currTrellis(i) holds the probability of being
      //       in state i given the first obsIter tokens in obsSeq

      stateItr = 0
      while (stateItr < numStates) {
	prevTrellis(stateItr) = currTrellis(stateItr)
	stateItr = stateItr + 1
      }
      obsItr = obsItr + 1
    }

    var sum  = 0.0
    stateItr = 0
    while (stateItr < numStates){
      sum = sum + currTrellis(stateItr)
      stateItr = stateItr + 1
    }

    return sum
  }

  /* FUTURE WORK: 1) Work in log-space
   *              2) better names!
   *
   * Implements the Viterbi algorithm for Hmms.  Given an observation sequence
   * and an Hmm, calculate the most likely sequence of states to have
   * generated the sequence
   *
   * PRECONDITION: All values in obsSeq are valid observations (i.e. every
   * observation is an integer less than the total number of distinct
   * observations.
   *
   * Returns a sequence of ints corresponding to the sequence of most likely
   * states to have produced this sequence
   */
  def decode(obsSeq: Seq[Int]): Seq[Int] = {
    var prevTrellis = new Array[Double](numStates)
    var currTrellis = new Array[Double](numStates)
    var probOfState = new Array[Double](numStates)
    var viterbiPath = new Array[Array[Int]](numStates)  //optimal path

    var obsItr = 0
    var currState = 0
    var stateItr  = 0
    while (stateItr < numStates) {
      viterbiPath(stateItr) = new Array[Int](obsSeq.length)
      prevTrellis(stateItr) = pi(stateItr) * A(stateItr)(obsSeq(obsItr))
      stateItr += 1
    }

    obsItr = 1
    while (obsItr < obsSeq.length) {

      currState = 0
      while (currState < numStates) {

	stateItr = 0
	while (stateItr < numStates) {
	  probOfState(stateItr) = prevTrellis(stateItr)*T(stateItr)(currState)
	  stateItr += 1
	}

	currTrellis(currState) = probOfState.max * A(currState)(obsSeq(obsItr))

	// get index of largest probability
	viterbiPath(currState)(obsItr) = probOfState.zipWithIndex.max._2
	currState += 1
      }

      stateItr = 0
      while (stateItr < numStates) {
	prevTrellis(stateItr) = currTrellis(stateItr)
	stateItr += 1
      }
      obsItr += 1
    }

    var hiddenStateSeq = new Array[Int](obsSeq.length)
    var maxProbIndex   = currTrellis.zipWithIndex.max._2
    obsItr = obsSeq.length - 1
    while (obsItr >= 0) {
      hiddenStateSeq(obsItr) = maxProbIndex
      maxProbIndex = viterbiPath(maxProbIndex)(obsItr)
      obsItr -= 1
    }

    return hiddenStateSeq
  }

  /* Implemenmts inverse transform sampling from an unnormalized distribution
   *  return value: random index into dist chosen proportional to the weight
   *  stored in that bin (think of dist as an unnormalized multinomial)
   */
  private def inverseSample(dist: Array[Double]): Int = {
    var sum    = dist.sum
    var prev   = 0.0
    val sample = rand.nextDouble() * sum     // rand is from class
    val dSize  = dist.length

    var i = 0
    while(i < dSize) {
      prev = prev + dist(i)
      if (sample < prev) {
	return i
      }
      i = i + 1
    }
    return dSize
  }
}


