import scala.util.Random

/* pi is an M length array of unnormalized initial state probabilities
 * T is an MxM matrix of state transition probabilities (Transition Matrix)
 * A is an MxO matrix of emission probabilities where O is the number
 *   of possible emission possibilities in any state (Action Matrix)
 *
 * PRCONDITIONS:
 *   T must be square
 *   A must have the same number of rows as T
 *
 * Probability matrices may be unnormalized
 */
class Hmm(val pi: Array[Double], val T: Array[Array[Double]],
	  val A:  Array[Array[Double]]) {

  val rand = new Random()
  val numStates  = T.length
  val numActions = A.length

  def genObsSeq(steps: Int): Seq[Int] = {
    val observations: Array[Int] = new Array[Int](steps)

    var step = 0
    var currState = inverseSample(pi)
    while(step < steps) {
      observations(step) = inverseSample(A(currState))
      currState = inverseSample(T(currState))
      step = step + 1
    }

    return observations
  }

  /* FUTURE WORK: 1) add probabilities in log space to prevent underflow
   *              2) add map so that obs sequence can be other than Int
   *
   * This function implements the forward algorithm (given a set of
   * observations, it returns the probability of that set of observations
   * having come from THIS Hmm).
   *
   * PRECONDITIONS:
   *   This Hmm must have an A and a T matrix
   *   all of the observations should be valid (could have possibly been
   *     generated by this Hmm
   */
  def forward(obsSeq: Seq[Int]): Double = {
    var prevTrellis = new Array[Double](numStates)
    var currTrellis = new Array[Double](numStates)

    var obsItr    = 0
    var stateItr  = 0   // generic itr
    var currState = 0
    while(stateItr < numStates) {        // Initialize
      prevTrellis(stateItr) = pi(stateItr) * A(stateItr)(obsSeq(obsItr));
      stateItr = stateItr + 1
    }

    var alpha = 0.0     // alpha stores partial sums of the probability of
                        // of being in a given state after having seen the
                        // first N tokens of the observation sequence
    obsItr    = 1
    currState = 1
    while (obsItr < obsSeq.length) {
      while (currState < numStates) {
	alpha    = 0.0
	stateItr = 0

	while (stateItr < numStates) {
	  // I should replace the line below with a dot product
	  alpha    = alpha + prevTrellis(stateItr) * T(stateItr)(currState)
	  stateItr = stateItr + 1
	}
	alpha = alpha * A(currState)(obsSeq(obsItr))
	currTrellis(currState) = alpha
	currState = currState + 1
      }

      // NOTE: at this point, currTrellis(i) holds the probability of being
      //       in state i given the first obsIter tokens in obsSeq

      stateItr = 0
      while (stateItr < numStates) {
	prevTrellis(stateItr) = currTrellis(stateItr)
	stateItr = stateItr + 1
      }
      obsItr = obsItr + 1
    }

    var sum  = 0.0
    stateItr = 0
    while (stateItr < numStates){
      sum = sum + currTrellis(stateItr)
      stateItr = stateItr + 1
    }

    return sum
  }

  /* Implemenmts inverse transform sampling from an unnormalized distribution
   *  return value: random index into dist chosen proportional to the weight
   *  stored in that bin (think of dist as an unnormalized multinomial)
   */
  private def inverseSample(dist: Array[Double]): Int = {
    var sum    = dist.sum
    var prev   = 0.0
    val sample = rand.nextDouble() * sum     // rand is from class
    val dSize  = dist.length

    var i = 0
    while(i < dSize) {
      prev = prev + dist(i)
      if (sample < prev) {
	return i
      }
      i = i + 1
    }
    return dSize
  }
}


